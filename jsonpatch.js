// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (function(root, factory) {
    if (typeof exports !== 'undefined') {
      return factory(root, require('lodash'));
    } else {
      return root.jsonpatch = factory(root, window._);
    }
  })(this, function(root, _) {
    var AddPatch, BothRefsPatch, CopyPatch, InvalidPatchError, InvalidPointerError, JSONPatch, JSONPatchError, JSONPointer, MovePatch, PatchConflictError, RemovePatch, ReplacePatch, SourceRefPatch, TargetRefPatch, TestPatch, Wildcard, apply, cloneDeep, coerce, coerceForArray, coerceForObject, compile, hasOwnProperty, isArray, isEqual, isObject, isString, listIndices, listKeys, operationMap, toString, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    toString = Object.prototype.toString;
    hasOwnProperty = Object.prototype.hasOwnProperty;
    isArray = _.isArray;
    isObject = _.isObject;
    isString = _.isString;
    isEqual = _.isEqual;
    listIndices = function(arr) {
      var _i, _ref, _results;
      return (function() {
        _results = [];
        for (var _i = 0, _ref = arr.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    };
    listKeys = _.keys;
    cloneDeep = _.cloneDeep;
    coerceForArray = function(reference, accessor, modify, adjust) {
      switch (false) {
        case accessor !== '-':
          accessor = reference.length;
          break;
        case !/^\d+$/.test(accessor):
          accessor = parseInt(accessor, 10);
          break;
        default:
          return null;
      }
      if (modify && adjust) {
        accessor = Math.min(accessor, reference.length);
      }
      if (accessor < reference.length + (modify ? 1 : 0)) {
        return accessor;
      }
      return null;
    };
    coerceForObject = function(reference, accessor, modify) {
      if (modify || accessor in reference) {
        return accessor;
      }
      return null;
    };
    coerce = function(reference, accessor, modify, adjust) {
      switch (false) {
        case !isArray(reference):
          return coerceForArray(reference, accessor, modify, adjust);
        case !isObject(reference):
          return coerceForObject(reference, accessor, modify);
        default:
          return null;
      }
    };
    JSONPatchError = (function(_super) {
      __extends(JSONPatchError, _super);

      function JSONPatchError(message) {
        this.message = message != null ? message : 'JSON patch error';
        this.name = 'JSONPatchError';
      }

      return JSONPatchError;

    })(Error);
    InvalidPointerError = (function(_super) {
      __extends(InvalidPointerError, _super);

      function InvalidPointerError(message) {
        this.message = message != null ? message : 'Invalid pointer';
        this.name = 'InvalidPointer';
      }

      return InvalidPointerError;

    })(Error);
    InvalidPatchError = (function(_super) {
      __extends(InvalidPatchError, _super);

      function InvalidPatchError(message) {
        this.message = message != null ? message : 'Invalid patch';
        this.name = 'InvalidPatch';
      }

      return InvalidPatchError;

    })(JSONPatchError);
    PatchConflictError = (function(_super) {
      __extends(PatchConflictError, _super);

      function PatchConflictError(message) {
        this.message = message != null ? message : 'Patch conflict';
        this.name = 'PatchConflictError';
      }

      return PatchConflictError;

    })(JSONPatchError);
    Wildcard = {};
    JSONPointer = (function() {
      function JSONPointer(path) {
        this.findReference = __bind(this.findReference, this);
        var i, lookaheads, step, steps, _i, _len, _ref;
        steps = [];
        lookaheads = [];
        if (path && (steps = path.split('/')).shift() !== '') {
          throw new InvalidPointerError('Path must be empty or start with /');
        }
        for (i = _i = 0, _len = steps.length; _i < _len; i = ++_i) {
          step = steps[i];
          _ref = this.decodeStep(step), steps[i] = _ref[0], lookaheads[i] = _ref[1];
        }
        this.steps = steps;
        this.lookaheads = lookaheads;
        this.path = path;
      }

      JSONPointer.prototype.decodeStep = function(step) {
        var lookahead, match;
        match = /^([^\[]*)(\[([^\]=]*)=([^\]]*)\])?$/.exec(step);
        if (match == null) {
          throw new InvalidPointerError("Invalid component");
        }
        lookahead = match[2] ? [match[3], match[4]] : null;
        step = match[1] === '*' ? Wildcard : this.unescape(match[1]);
        return [step, lookahead];
      };

      JSONPointer.prototype.unescape = function(step) {
        return step.replace('~2', '*').replace('~1', '/').replace('~0', '~');
      };

      JSONPointer.prototype.getReference = function(object, modify, lax) {
        if (!this.steps.length) {
          return [null, object];
        }
        return this.findReference(object, 0, modify, lax);
      };

      JSONPointer.prototype.findReference = function(object, level, modify, lax) {
        var acc, accessors, isLast, matchLookahead, ref, step, _i, _len, _ref,
          _this = this;
        matchLookahead = function(object) {
          var key, value, _ref;
          if (!_this.lookaheads[level]) {
            return true;
          }
          if (!(isArray(object) || isObject(object))) {
            return false;
          }
          _ref = _this.lookaheads[level], key = _ref[0], value = _ref[1];
          return key in object && object[key] === value;
        };
        step = this.steps[level];
        isLast = level === this.steps.length - 1;
        if (step === Wildcard) {
          accessors = (function() {
            switch (false) {
              case !isArray(object):
                return listIndices(object);
              case !isObject(object):
                return listKeys(object);
              default:
                return [];
            }
          })();
        } else {
          acc = coerce(object, step, modify && isLast, lax);
          accessors = acc != null ? [acc] : [];
        }
        for (_i = 0, _len = accessors.length; _i < _len; _i++) {
          acc = accessors[_i];
          if (!matchLookahead(object[acc])) {
            continue;
          }
          if (isLast) {
            return [object, acc];
          }
          _ref = this.findReference(object[acc], level + 1, modify, lax), ref = _ref[0], acc = _ref[1];
          if (acc != null) {
            return [ref, acc];
          }
        }
        return [object, null];
      };

      return JSONPointer;

    })();
    JSONPatch = (function() {
      function JSONPatch(patch) {
        if (!('path' in patch)) {
          throw new InvalidPatchError('Missing path');
        }
        this.validate(patch);
        this.patch = patch;
        this.path = new JSONPointer(patch.path);
        this.initialize(patch);
      }

      JSONPatch.prototype.initialize = function() {};

      JSONPatch.prototype.validate = function(patch) {};

      JSONPatch.prototype.apply = function(document, lax) {
        if (lax == null) {
          lax = true;
        }
        return this.applyInPlace(cloneDeep(document), lax);
      };

      return JSONPatch;

    })();
    SourceRefPatch = (function(_super) {
      __extends(SourceRefPatch, _super);

      function SourceRefPatch() {
        _ref = SourceRefPatch.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      SourceRefPatch.prototype.applyInPlace = function(document, lax) {
        var accessor, reference, value, _ref1;
        _ref1 = this.path.getReference(document, false), reference = _ref1[0], accessor = _ref1[1];
        if (accessor == null) {
          if (lax) {
            return document;
          }
          throw new PatchConflictError("Source path '" + this.path.path + "' not found");
        }
        value = this.patch.value;
        return this.realApply(document, reference, accessor, value, lax);
      };

      return SourceRefPatch;

    })(JSONPatch);
    TargetRefPatch = (function(_super) {
      __extends(TargetRefPatch, _super);

      function TargetRefPatch() {
        _ref1 = TargetRefPatch.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      TargetRefPatch.prototype.applyInPlace = function(document, lax) {
        var accessor, reference, value, _ref2;
        _ref2 = this.path.getReference(document, true, lax), reference = _ref2[0], accessor = _ref2[1];
        if (accessor == null) {
          if (lax) {
            return document;
          }
          throw new PatchConflictError("Target path '" + this.path.path + "' not found");
        }
        value = this.patch.value;
        return this.realApply(document, reference, accessor, value, lax);
      };

      return TargetRefPatch;

    })(JSONPatch);
    BothRefsPatch = (function(_super) {
      __extends(BothRefsPatch, _super);

      function BothRefsPatch() {
        _ref2 = BothRefsPatch.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      BothRefsPatch.prototype.initialize = function(patch) {
        var i, isPrefix, _i, _ref3;
        this.from = new JSONPointer(patch.from);
        isPrefix = true;
        for (i = _i = 0, _ref3 = this.from.steps.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
          if (this.from.steps[i] !== this.path.steps[i]) {
            isPrefix = false;
            break;
          }
        }
        if (isPrefix) {
          if (this.from.steps.length === this.path.steps.length) {
            return this.applyInPlace = function(document) {
              return document;
            };
          } else {
            throw new InvalidPatchError("Cannot move or copy into ancestor");
          }
        }
      };

      BothRefsPatch.prototype.applyInPlace = function(document, lax) {
        var fromAccessor, fromReference, toAccessor, toReference, _ref3, _ref4;
        _ref3 = this.from.getReference(document, false), fromReference = _ref3[0], fromAccessor = _ref3[1];
        if (fromAccessor == null) {
          if (lax) {
            return document;
          }
          throw new PatchConflictError("Source path '" + this.from.path + "' not found");
        }
        _ref4 = this.path.getReference(document, true, lax), toReference = _ref4[0], toAccessor = _ref4[1];
        if (toAccessor == null) {
          if (lax) {
            return document;
          }
          throw new PatchConflictError("Target path '" + this.path.path + "' not found");
        }
        return this.realApply(document, fromReference, fromAccessor, toReference, toAccessor, lax);
      };

      return BothRefsPatch;

    })(JSONPatch);
    AddPatch = (function(_super) {
      __extends(AddPatch, _super);

      function AddPatch() {
        _ref3 = AddPatch.__super__.constructor.apply(this, arguments);
        return _ref3;
      }

      AddPatch.prototype.validate = function(patch) {
        if (!('value' in patch)) {
          throw new InvalidPatchError('Missing value');
        }
      };

      AddPatch.prototype.realApply = function(document, reference, accessor, value, lax) {
        if (reference == null) {
          document = value;
        } else if (isArray(reference)) {
          reference.splice(accessor, 0, value);
        } else {
          reference[accessor] = value;
        }
        return document;
      };

      return AddPatch;

    })(TargetRefPatch);
    RemovePatch = (function(_super) {
      __extends(RemovePatch, _super);

      function RemovePatch() {
        _ref4 = RemovePatch.__super__.constructor.apply(this, arguments);
        return _ref4;
      }

      RemovePatch.prototype.realApply = function(document, reference, accessor, value, lax) {
        if (reference == null) {
          throw new InvalidPatchError("Can't remove root document");
        }
        if (isArray(reference)) {
          reference.splice(accessor, 1);
        } else {
          delete reference[accessor];
        }
        return document;
      };

      return RemovePatch;

    })(SourceRefPatch);
    ReplacePatch = (function(_super) {
      __extends(ReplacePatch, _super);

      function ReplacePatch() {
        _ref5 = ReplacePatch.__super__.constructor.apply(this, arguments);
        return _ref5;
      }

      ReplacePatch.prototype.validate = function(patch) {
        if (!('value' in patch)) {
          throw new InvalidPatchError('Missing value');
        }
      };

      ReplacePatch.prototype.applyInPlace = function(document, lax) {
        if (lax) {
          return TargetRefPatch.prototype.applyInPlace.call(this, document, lax);
        } else {
          return SourceRefPatch.prototype.applyInPlace.call(this, document, lax);
        }
      };

      ReplacePatch.prototype.realApply = function(document, reference, accessor, value, lax) {
        if (reference == null) {
          document = value;
        } else {
          if (isArray(reference)) {
            reference.splice(accessor, 1, value);
          } else {
            reference[accessor] = value;
          }
        }
        return document;
      };

      return ReplacePatch;

    })(JSONPatch);
    TestPatch = (function(_super) {
      __extends(TestPatch, _super);

      function TestPatch() {
        _ref6 = TestPatch.__super__.constructor.apply(this, arguments);
        return _ref6;
      }

      TestPatch.prototype.validate = function(patch) {
        if (!('value' in patch)) {
          throw new InvalidPatchError('Missing value');
        }
      };

      TestPatch.prototype.realApply = function(document, reference, accessor, value, lax) {
        var result;
        if (reference == null) {
          result = isEqual(document, value);
        } else {
          result = isEqual(reference[accessor], value);
        }
        if (!result) {
          if (lax) {
            return document;
          }
          throw new PatchConflictError("Test on path '" + this.path.path + "' failed");
        }
        return document;
      };

      return TestPatch;

    })(SourceRefPatch);
    MovePatch = (function(_super) {
      __extends(MovePatch, _super);

      function MovePatch() {
        _ref7 = MovePatch.__super__.constructor.apply(this, arguments);
        return _ref7;
      }

      MovePatch.prototype.validate = function(patch) {
        if (!('from' in patch)) {
          throw new InvalidPatchError('Missing from');
        }
      };

      MovePatch.prototype.realApply = function(document, fromReference, fromAccessor, toReference, toAccessor, lax) {
        var value;
        if (isArray(fromReference)) {
          value = fromReference.splice(fromAccessor, 1)[0];
        } else {
          value = fromReference[fromAccessor];
          delete fromReference[fromAccessor];
        }
        if (toReference == null) {
          document = value;
        } else if (isArray(toReference)) {
          toReference.splice(toAccessor, 0, value);
        } else {
          toReference[toAccessor] = value;
        }
        return document;
      };

      return MovePatch;

    })(BothRefsPatch);
    CopyPatch = (function(_super) {
      __extends(CopyPatch, _super);

      function CopyPatch() {
        _ref8 = CopyPatch.__super__.constructor.apply(this, arguments);
        return _ref8;
      }

      CopyPatch.prototype.validate = function(patch) {
        if (!('from' in patch)) {
          throw new InvalidPatchError('Missing from');
        }
      };

      CopyPatch.prototype.realApply = function(document, fromReference, fromAccessor, toReference, toAccessor, lax) {
        var value;
        if (isArray(fromReference)) {
          value = fromReference.slice(fromAccessor, fromAccessor + 1)[0];
        } else {
          value = fromReference[fromAccessor];
        }
        if (toReference == null) {
          document = value;
        } else if (isArray(toReference)) {
          toReference.splice(toAccessor, 0, value);
        } else {
          toReference[toAccessor] = value;
        }
        return document;
      };

      return CopyPatch;

    })(BothRefsPatch);
    operationMap = {
      add: AddPatch,
      remove: RemovePatch,
      replace: ReplacePatch,
      move: MovePatch,
      copy: CopyPatch,
      test: TestPatch
    };
    compile = function(patch) {
      var klass, ops, p, _i, _len;
      ops = [];
      for (_i = 0, _len = patch.length; _i < _len; _i++) {
        p = patch[_i];
        if (!p.op) {
          throw new InvalidPatchError('Missing operation');
        }
        if (!(klass = operationMap[p.op])) {
          throw new InvalidPatchError('Invalid operation');
        }
        ops.push(new klass(p));
      }
      return function(document, lax) {
        var op, result, _j, _len1;
        if (lax == null) {
          lax = true;
        }
        result = cloneDeep(document);
        for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
          op = ops[_j];
          result = op.applyInPlace(document, lax);
        }
        return result;
      };
    };
    apply = function(document, patch, lax) {
      if (lax == null) {
        lax = true;
      }
      return compile(patch)(document, lax);
    };
    root.apply = apply;
    root.compile = compile;
    root.JSONPointer = JSONPointer;
    root.JSONPatch = JSONPatch;
    root.JSONPatchError = JSONPatchError;
    root.InvalidPointerError = InvalidPointerError;
    root.InvalidPatchError = InvalidPatchError;
    root.PatchConflictError = PatchConflictError;
    return root;
  });

}).call(this);
